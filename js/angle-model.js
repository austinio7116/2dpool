/* eslint-disable no-var, prefer-const */
/**
 * Auto-generated angle error model.
 *
 * Trained on: ai_shot_data_1770229525653.json
 * Features: cutAngle, spinY, power
 * Network: 3 -> 8 -> 8 -> 1 (tanh, tanh, linear)
 * Target clip: [-15, 15] degrees
 * Metrics (holdout test, random_state=42):
 *   rSquared: 0.011303
 *   rmse: 1.032862
 *   mae: 0.083578
 *
 * Generated by build_angle_model.py
 */

// Feature order: ['cutAngle','spinY','power']
const __ANGLE_SCALER_MEAN = [36.8290636, -0.04409599529, 15.4807126];
const __ANGLE_SCALER_SCALE = [20.85088734, 0.6992069428, 6.843095457];

// MLP weights (sklearn-style: coefs_ and intercepts_)
// W[0] is 3x8, W[1] is 8x8, W[2] is 8x1
const __ANGLE_W = [
  [
    [0.1016540926, 0.1244673539, 0.05613405091, -0.2726753559, 0.1729078978, -0.09435062121, -0.2291712712, 0.2192258233],
    [0.05451427439, -0.04330646438, -0.2257510735, 0.06473855849, 0.1437775419, -0.02832131708, -0.09468443559, 0.03534175312],
    [0.03858927596, -0.04837493068, 0.04955193553, -0.1207630372, 0.08845685967, -0.1204438598, -0.1278034048, 0.1828148952]
  ],
  [
    [-1.12960391, 1.080113886, 0.9747966414, -0.381871673, 0.1550842649, 0.08470091471, 0.7964205662, 0.5092394859],
    [0.00888906378, -0.463373186, -1.139965122, 1.07736516, -0.6553040858, -0.2941501578, -0.6836046197, -0.4938132407],
    [-0.3697584662, 0.007486929618, 1.04802676, -0.3635888441, 0.9012529486, 0.9287019439, 0.5277091114, 0.9866696016],
    [0.05786175662, -1.000147763, -0.5094337713, 0.6696839846, -0.1837894022, -0.9463063813, -0.2208052356, -0.8960993153],
    [-0.4783386704, 0.3020060701, -0.05599941887, -0.5631479922, -0.2464493785, 0.8914459879, 0.6351488404, 0.1232820363],
    [-1.041482146, 0.7802446447, 0.6794318119, -0.2858241403, 0.7061165409, -0.07161439373, 0.2375911315, -0.003126567557],
    [1.025252387, -0.2844784158, -0.4753465345, 0.1542577341, -0.5818459362, -0.7496830883, -0.180415391, -0.4230652872],
    [0.02105158141, 0.3701426799, -0.09496418357, -0.5447180159, 0.7633132025, 0.5429606946, 0.7575953125, 0.4951787876]
  ],
  [
    [2.025206235],
    [-1.71865485],
    [-1.226927236],
    [1.309420393],
    [-1.526248],
    [-1.94779503],
    [-1.581345538],
    [-2.009981793]
  ]
];

// Biases for each layer: b[0] len 8, b[1] len 8, b[2] len 1
const __ANGLE_B = [
  [-0.606193044, 1.113453142, -0.9162417278, 0.7636750206, -0.6569932637, -1.156587016, 0.8086994467, -1.021675325],
  [0.3783332786, -0.4029785311, -0.8248764215, 0.01949654273, -0.8347075377, -0.1956092577, -0.5441550406, -0.3766782678],
  [1.677355211]
];

/**
 * Predict the angle error for a shot
 * @param {number} cutAngle - Cut angle in degrees (0 = straight, 90 = max)
 * @param {number} spinY - Vertical spin (-1 to 1, positive = topspin)
 * @param {number} power - Shot power
 * @returns {number} Predicted angle error in degrees
 *
 * Model details:
 * - Trained on: ai_shot_data_1770229525653.json
 * - Features: [cutAngle, spinY, power]
 * - Network: 3 -> 8 -> 8 -> 1 with tanh activations
 * - Output clipped to [-15, 15] degrees (training targets were clipped)
 */
function predictAngleError(cutAngle, spinY, power) {
  // basic input sanitization (avoid NaN/Infinity propagating)
  if (!Number.isFinite(cutAngle) || !Number.isFinite(spinY) || !Number.isFinite(power)) return 0;

  const mean = __ANGLE_SCALER_MEAN;
  const scale = __ANGLE_SCALER_SCALE;
  const W = __ANGLE_W;
  const b = __ANGLE_B;

  // normalize inputs
  const x = [
    (cutAngle - mean[0]) / scale[0],
    (spinY   - mean[1]) / scale[1],
    (power   - mean[2]) / scale[2]
  ];

  const tanh = (z) => Math.tanh(z);

  // layer 1: 3 -> 8 (tanh)
  const h1 = new Array(8);
  for (let j = 0; j < 8; j++) {
    let s = b[0][j];
    for (let i = 0; i < 3; i++) s += x[i] * W[0][i][j];
    h1[j] = tanh(s);
  }

  // layer 2: 8 -> 8 (tanh)
  const h2 = new Array(8);
  for (let j = 0; j < 8; j++) {
    let s = b[1][j];
    for (let i = 0; i < 8; i++) s += h1[i] * W[1][i][j];
    h2[j] = tanh(s);
  }

  // output: 8 -> 1 (linear)
  let y = b[2][0];
  for (let i = 0; i < 8; i++) y += h2[i] * W[2][i][0];

  // clip to training range
  if (y > 15) y = 15;
  else if (y < -15) y = -15;

  return y;
}

/**
 * Calculate aim adjustment to compensate for predicted angle error
 * @param {number} cutAngle - Cut angle in degrees
 * @param {number} spinY - Vertical spin
 * @param {number} power - Shot power
 * @returns {number} Angle adjustment in degrees (subtract from aim)
 */
function calculateAimAdjustment(cutAngle, spinY, power) {
  return predictAngleError(cutAngle, spinY, power);
}

// Model metadata
const ANGLE_MODEL_INFO = {
  modelType: "mlp_regression",
  degree: 2,
  clip: 15,
  nSamples: 8490,
  features: ["cutAngle", "spinY", "power"],
  network: {
    layers: [3, 8, 8, 1],
    activation: "tanh",
    solver: "adam",
    randomState: 42
  },
  metrics: {
    rSquared: 0.011303,
    rmse: 1.032862,
    mae: 0.083578
  }
};

// Export for use in modules
if (typeof module !== "undefined" && module.exports) {
  module.exports = { predictAngleError, calculateAimAdjustment, ANGLE_MODEL_INFO };
}
