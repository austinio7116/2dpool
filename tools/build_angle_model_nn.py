#!/usr/bin/env python3
"""
Usage:
    python build_angle_model.py <shot_data.json> [--degree N] [--output model.js]

Trains a small neural-network regression model to predict angleError from:
  - cutAngle, spinY, power

Outputs a self-contained JavaScript file that exports:
  - predictAngleError(cutAngle, spinY, power)
  - calculateAimAdjustment(cutAngle, spinY, power)
  - ANGLE_MODEL_INFO
"""

from __future__ import annotations

import argparse
import json
import math
from pathlib import Path
from typing import List, Any

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPRegressor
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score


FEATURES = ["cutAngle", "spinY", "power"]
TARGET = "angleError"


def _fmt(x: float) -> str:
    if abs(x) < 1e-12:
        x = 0.0
    return f"{float(x):.10g}"


def _js_array(obj: Any, indent: int = 0) -> str:
    sp = " " * indent
    if isinstance(obj, list):
        if len(obj) == 0:
            return "[]"
        if isinstance(obj[0], list):
            inner = ",\n".join(sp + "  " + _js_array(x, indent + 2) for x in obj)
            return "[\n" + inner + "\n" + sp + "]"
        return "[" + ", ".join(_fmt(float(x)) for x in obj) + "]"
    raise TypeError(f"Unsupported type for js export: {type(obj)}")


def build_js(
    data_name: str,
    mean: List[float],
    scale: List[float],
    W: List[List[List[float]]],
    b: List[List[float]],
    clip: float,
    degree: int,
    n_samples: int,
    r2: float,
    rmse: float,
    mae: float,
) -> str:
    # Self-contained model.js replacement
    return f"""\
/* eslint-disable no-var, prefer-const */
/**
 * Auto-generated angle error model.
 *
 * Trained on: {data_name}
 * Features: cutAngle, spinY, power
 * Network: 3 -> 8 -> 8 -> 1 (tanh, tanh, linear)
 * Target clip: [-{clip:g}, {clip:g}] degrees
 * Metrics (holdout test, random_state=42):
 *   rSquared: {r2:.6f}
 *   rmse: {rmse:.6f}
 *   mae: {mae:.6f}
 *
 * Generated by build_angle_model.py
 */

// Feature order: ['cutAngle','spinY','power']
const __ANGLE_SCALER_MEAN = {_js_array(mean)};
const __ANGLE_SCALER_SCALE = {_js_array(scale)};

// MLP weights (sklearn-style: coefs_ and intercepts_)
// W[0] is 3x8, W[1] is 8x8, W[2] is 8x1
const __ANGLE_W = {_js_array(W)};

// Biases for each layer: b[0] len 8, b[1] len 8, b[2] len 1
const __ANGLE_B = {_js_array(b)};

/**
 * Predict the angle error for a shot
 * @param {{number}} cutAngle - Cut angle in degrees (0 = straight, 90 = max)
 * @param {{number}} spinY - Vertical spin (-1 to 1, positive = topspin)
 * @param {{number}} power - Shot power
 * @returns {{number}} Predicted angle error in degrees
 *
 * Model details:
 * - Trained on: {data_name}
 * - Features: [cutAngle, spinY, power]
 * - Network: 3 -> 8 -> 8 -> 1 with tanh activations
 * - Output clipped to [-{clip:g}, {clip:g}] degrees (training targets were clipped)
 */
function predictAngleError(cutAngle, spinY, power) {{
  // basic input sanitization (avoid NaN/Infinity propagating)
  if (!Number.isFinite(cutAngle) || !Number.isFinite(spinY) || !Number.isFinite(power)) return 0;

  const mean = __ANGLE_SCALER_MEAN;
  const scale = __ANGLE_SCALER_SCALE;
  const W = __ANGLE_W;
  const b = __ANGLE_B;

  // normalize inputs
  const x = [
    (cutAngle - mean[0]) / scale[0],
    (spinY   - mean[1]) / scale[1],
    (power   - mean[2]) / scale[2]
  ];

  const tanh = (z) => Math.tanh(z);

  // layer 1: 3 -> 8 (tanh)
  const h1 = new Array(8);
  for (let j = 0; j < 8; j++) {{
    let s = b[0][j];
    for (let i = 0; i < 3; i++) s += x[i] * W[0][i][j];
    h1[j] = tanh(s);
  }}

  // layer 2: 8 -> 8 (tanh)
  const h2 = new Array(8);
  for (let j = 0; j < 8; j++) {{
    let s = b[1][j];
    for (let i = 0; i < 8; i++) s += h1[i] * W[1][i][j];
    h2[j] = tanh(s);
  }}

  // output: 8 -> 1 (linear)
  let y = b[2][0];
  for (let i = 0; i < 8; i++) y += h2[i] * W[2][i][0];

  // clip to training range
  if (y > {clip:g}) y = {clip:g};
  else if (y < -{clip:g}) y = -{clip:g};

  return y;
}}

/**
 * Calculate aim adjustment to compensate for predicted angle error
 * @param {{number}} cutAngle - Cut angle in degrees
 * @param {{number}} spinY - Vertical spin
 * @param {{number}} power - Shot power
 * @returns {{number}} Angle adjustment in degrees (subtract from aim)
 */
function calculateAimAdjustment(cutAngle, spinY, power) {{
  return predictAngleError(cutAngle, spinY, power);
}}

// Model metadata
const ANGLE_MODEL_INFO = {{
  modelType: "mlp_regression",
  degree: {degree},
  clip: {clip:g},
  nSamples: {n_samples},
  features: ["cutAngle", "spinY", "power"],
  network: {{
    layers: [3, 8, 8, 1],
    activation: "tanh",
    solver: "adam",
    randomState: 42
  }},
  metrics: {{
    rSquared: {r2:.6f},
    rmse: {rmse:.6f},
    mae: {mae:.6f}
  }}
}};

// Export for use in modules
if (typeof module !== "undefined" && module.exports) {{
  module.exports = {{ predictAngleError, calculateAimAdjustment, ANGLE_MODEL_INFO }};
}}
"""


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("shot_data", type=str, help="Path to shot_data.json")
    ap.add_argument("--degree", type=int, default=2, help="Metadata passthrough (kept for compatibility)")
    ap.add_argument("--output", type=str, default="model.js", help="Output JS file path")
    ap.add_argument("--clip", type=float, default=15.0, help="Clip target/output to [-clip, clip]")
    ap.add_argument("--seed", type=int, default=42, help="Random seed")
    args = ap.parse_args()

    data_path = Path(args.shot_data)
    raw = json.loads(data_path.read_text())

    # Build X/y
    X = np.array([[row[f] for f in FEATURES] for row in raw], dtype=np.float64)
    y = np.array([row[TARGET] for row in raw], dtype=np.float64)
    y = np.clip(y, -args.clip, args.clip)

    # Train/test split for metrics
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=args.seed
    )

    # Standardize -> MLP (LBFGS for deterministic results on small datasets)
    pipe = Pipeline(
        steps=[
            ("scaler", StandardScaler()),
            (
                "mlp",
                MLPRegressor(
                    hidden_layer_sizes=(8, 8),
                    activation="tanh",
                    solver="adam",
                    alpha=1e-4,
                    learning_rate_init=1e-3,
                    max_iter=5000,
                    early_stopping=True,
                    validation_fraction=0.15,
                    n_iter_no_change=50,
                    random_state=args.seed,
                ),
            ),
        ]
    )
    pipe.fit(X_train, y_train)

    # Metrics
    pred = pipe.predict(X_test)
    mae = mean_absolute_error(y_test, pred)
    rmse = math.sqrt(mean_squared_error(y_test, pred))
    r2 = r2_score(y_test, pred)

    scaler: StandardScaler = pipe.named_steps["scaler"]
    mlp: MLPRegressor = pipe.named_steps["mlp"]

    mean = scaler.mean_.tolist()
    scale = scaler.scale_.tolist()
    W = [w.tolist() for w in mlp.coefs_]
    b = [bb.tolist() for bb in mlp.intercepts_]

    out_js = build_js(
        data_name=data_path.name,
        mean=mean,
        scale=scale,
        W=W,
        b=b,
        clip=args.clip,
        degree=args.degree,
        n_samples=len(raw),
        r2=r2,
        rmse=rmse,
        mae=mae,
    )

    out_path = Path(args.output)
    out_path.write_text(out_js, encoding="utf-8")

    print("Wrote:", out_path)
    print(f"Test metrics: r2={r2:.6f}, rmse={rmse:.6f}, mae={mae:.6f}")


if __name__ == "__main__":
    main()
