/* eslint-disable no-var, prefer-const */
/**
 * Auto-generated angle error model.
 *
 * Trained on: ai_shot_data_1770309062784.json
 * Features: cutAngle, spinY, power
 * Model: piecewise PolynomialFeatures(degree=3) + Ridge
 * Output clip: [-15, 15] degrees
 * Generated (UTC): 2026-02-05 16:31:21Z
 * Metrics (overall holdout test, random_state=42):
 *   rSquared: 0.698782
 *   rmse: 1.461002
 *   mae: 0.780493
 *
 * Generated by build_angle_model_nn.py
 */

// Bracket 0: power in [0.0, 10.0) (n=450, split=28, rmse=0.5714)
function __predictAngleError_b0_left(cutAngle, power) {
  return (
    -9.97329201968e-07 * 1.0 +
    0.000255676896752 * (cutAngle) +
    -4.98664554515e-06 * (power) +
    -3.43070473156e-05 * (Math.pow(cutAngle, 2)) +
    0.00127838447568 * (cutAngle * power) +
    -2.49332295867e-05 * (Math.pow(power, 2)) +
    4.26798932367e-05 * (Math.pow(cutAngle, 3)) +
    -0.000171535001187 * (Math.pow(cutAngle, 2) * power) +
    0.00639192242163 * (cutAngle * Math.pow(power, 2)) +
    -0.000124666135205 * (Math.pow(power, 3))
  );
}

function __predictAngleError_b0_right(cutAngle, power) {
  return (
    0.000227726074305 * 1.0 +
    0.000162250364578 * (cutAngle) +
    0.00113863037177 * (power) +
    -9.67637346291e-05 * (Math.pow(cutAngle, 2)) +
    0.000811251730541 * (cutAngle * power) +
    0.00569315186121 * (Math.pow(power, 2)) +
    1.68833014234e-05 * (Math.pow(cutAngle, 3)) +
    -0.000483820566393 * (Math.pow(cutAngle, 2) * power) +
    0.00405625975562 * (cutAngle * Math.pow(power, 2)) +
    0.0284657592652 * (Math.pow(power, 3))
  );
}

// Bracket 1: power in [10.0, 20.0) (n=1304, split=27, rmse=1.1698)
function __predictAngleError_b1_left(cutAngle, power) {
  return (
    -2.44518278954e-06 * 1.0 +
    0.00417830889845 * (cutAngle) +
    -2.02692963634e-05 * (power) +
    -0.000169090098659 * (Math.pow(cutAngle, 2)) +
    0.026317313486 * (cutAngle * power) +
    -0.000127684067837 * (Math.pow(power, 2)) +
    3.86117110676e-05 * (Math.pow(cutAngle, 3)) +
    -3.69716067924e-05 * (Math.pow(cutAngle, 2) * power) +
    -0.00112593780825 * (cutAngle * Math.pow(power, 2)) +
    5.02753981456e-06 * (Math.pow(power, 3))
  );
}

function __predictAngleError_b1_right(cutAngle, power) {
  return (
    0.000506609940409 * 1.0 +
    0.00645689158054 * (cutAngle) +
    0.00419975384009 * (power) +
    -0.00526371002954 * (Math.pow(cutAngle, 2)) +
    0.0406562454409 * (cutAngle * power) +
    0.0264602491611 * (Math.pow(power, 2)) +
    2.9457329625e-05 * (Math.pow(cutAngle, 3)) +
    6.47764708662e-05 * (Math.pow(cutAngle, 2) * power) +
    -0.00207877338883 * (cutAngle * Math.pow(power, 2)) +
    -0.000924470538186 * (Math.pow(power, 3))
  );
}

// Bracket 2: power in [20.0, 30.0) (n=1304, split=15, rmse=1.6418)
function __predictAngleError_b2_left(cutAngle, power) {
  return (
    -5.43196793615e-07 * 1.0 +
    0.00115109639425 * (cutAngle) +
    -8.57306475364e-06 * (power) +
    -0.00253026624796 * (Math.pow(cutAngle, 2)) +
    0.0136805701224 * (cutAngle * power) +
    -0.000101851281841 * (Math.pow(power, 2)) +
    -2.24301560423e-05 * (Math.pow(cutAngle, 3)) +
    0.000140586460536 * (Math.pow(cutAngle, 2) * power) +
    -0.000347382855593 * (cutAngle * Math.pow(power, 2)) +
    4.44474901939e-06 * (Math.pow(power, 3))
  );
}

function __predictAngleError_b2_right(cutAngle, power) {
  return (
    -0.000133954599204 * 1.0 +
    0.00450357995999 * (cutAngle) +
    -0.00211436703804 * (power) +
    -0.0130275942075 * (Math.pow(cutAngle, 2)) +
    0.053527913278 * (cutAngle * power) +
    -0.0251270095201 * (Math.pow(power, 2)) +
    8.55658053863e-05 * (Math.pow(cutAngle, 3)) +
    -2.35886776514e-05 * (Math.pow(cutAngle, 2) * power) +
    -0.00118304604723 * (cutAngle * Math.pow(power, 2)) +
    0.000727155881246 * (Math.pow(power, 3))
  );
}

// Bracket 3: power in [30.0, 40.0) (n=1284, split=44, rmse=1.3568)
function __predictAngleError_b3_left(cutAngle, power) {
  return (
    7.00270236463e-07 * 1.0 +
    0.000281614289416 * (cutAngle) +
    1.6205851347e-05 * (power) +
    0.00700014874907 * (Math.pow(cutAngle, 2)) +
    0.00489729096733 * (cutAngle * power) +
    0.000281778578776 * (Math.pow(power, 2)) +
    -0.000143832575919 * (Math.pow(cutAngle, 3)) +
    -4.39534868879e-05 * (Math.pow(cutAngle, 2) * power) +
    -7.2270631451e-05 * (cutAngle * Math.pow(power, 2)) +
    -6.77268353308e-06 * (Math.pow(power, 3))
  );
}

function __predictAngleError_b3_right(cutAngle, power) {
  return (
    -0.000479266092237 * 1.0 +
    0.013692856532 * (cutAngle) +
    -0.0110917650215 * (power) +
    -0.0653848172051 * (Math.pow(cutAngle, 2)) +
    0.238148329888 * (cutAngle * power) +
    -0.19288800408 * (Math.pow(power, 2)) +
    0.000625013630732 * (Math.pow(cutAngle, 3)) +
    -0.00137284315524 * (Math.pow(cutAngle, 2) * power) +
    -0.00149719706137 * (cutAngle * Math.pow(power, 2)) +
    0.00275664980572 * (Math.pow(power, 3))
  );
}

// Bracket 4: power in [40.0, 1000.0) (n=3183, split=47, rmse=1.6101)
function __predictAngleError_b4_left(cutAngle, power) {
  return (
    0.13072516159 * 1.0 +
    0.208211327184 * (cutAngle) +
    -0.026251581888 * (power) +
    0.00415341860093 * (Math.pow(cutAngle, 2)) +
    -0.00361466695596 * (cutAngle * power) +
    0.000816981508798 * (Math.pow(power, 2)) +
    -0.000112507146383 * (Math.pow(cutAngle, 3)) +
    -1.13760449126e-05 * (Math.pow(cutAngle, 2) * power) +
    3.30629270148e-05 * (cutAngle * Math.pow(power, 2)) +
    -7.12637408947e-06 * (Math.pow(power, 3))
  );
}

function __predictAngleError_b4_right(cutAngle, power) {
  return (
    -0.0583474016393 * 1.0 +
    7.64518559579 * (cutAngle) +
    -8.07518606482 * (power) +
    -0.158826087571 * (Math.pow(cutAngle, 2)) +
    0.058384827584 * (cutAngle * power) +
    0.121523680314 * (Math.pow(power, 2)) +
    0.000904174427392 * (Math.pow(cutAngle, 3)) +
    -7.94533455469e-05 * (Math.pow(cutAngle, 2) * power) +
    -0.000459430131562 * (cutAngle * Math.pow(power, 2)) +
    -0.000602485458246 * (Math.pow(power, 3))
  );
}

/**
 * Predict the angle error for a shot
 * @param {number} cutAngle - Cut angle in degrees (0 = straight, 90 = max)
 * @param {number} spinY - Vertical spin (-1 to 1, positive = topspin)
 * @param {number} power - Shot power
 * @returns {number} Predicted angle error in degrees
 */
function predictAngleError(cutAngle, spinY, power) {
  // basic input sanitization (avoid NaN/Infinity propagating)
  if (!Number.isFinite(cutAngle) || !Number.isFinite(spinY) || !Number.isFinite(power)) return 0;

  // NOTE: spinY is accepted for compatibility but not used by this model.

  if (power >= 0.0 && power < 10.0) {
    const split = 28;
    let y = (cutAngle < split)
      ? __predictAngleError_b0_left(cutAngle, power)
      : __predictAngleError_b0_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  else if (power >= 10.0 && power < 20.0) {
    const split = 27;
    let y = (cutAngle < split)
      ? __predictAngleError_b1_left(cutAngle, power)
      : __predictAngleError_b1_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  else if (power >= 20.0 && power < 30.0) {
    const split = 15;
    let y = (cutAngle < split)
      ? __predictAngleError_b2_left(cutAngle, power)
      : __predictAngleError_b2_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  else if (power >= 30.0 && power < 40.0) {
    const split = 44;
    let y = (cutAngle < split)
      ? __predictAngleError_b3_left(cutAngle, power)
      : __predictAngleError_b3_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  else if (power >= 40.0 && power < 1000.0) {
    const split = 47;
    let y = (cutAngle < split)
      ? __predictAngleError_b4_left(cutAngle, power)
      : __predictAngleError_b4_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  // fallback: clamp to nearest bracket
  if (power < 0.0) {
    const split = 28;
    let y = (cutAngle < split)
      ? __predictAngleError_b0_left(cutAngle, power)
      : __predictAngleError_b0_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
  {
    const split = 47;
    let y = (cutAngle < split)
      ? __predictAngleError_b4_left(cutAngle, power)
      : __predictAngleError_b4_right(cutAngle, power);
    if (y > 15) y = 15;
    else if (y < -15) y = -15;
    return y;
  }
}

/**
 * Calculate aim adjustment to compensate for predicted angle error
 * @param {number} cutAngle - Cut angle in degrees
 * @param {number} spinY - Vertical spin
 * @param {number} power - Shot power
 * @returns {number} Angle adjustment in degrees (subtract from aim)
 */
function calculateAimAdjustment(cutAngle, spinY, power) {
  return predictAngleError(cutAngle, spinY, power);
}

// Model metadata
const ANGLE_MODEL_INFO = {
  modelType: "piecewise_poly_ridge",
  degree: 3,
  clip: 15,
  nSamples: 7525,
  features: ["cutAngle", "spinY", "power"],
  piecewise: {
    brackets: [
      { pmin: 0.0, pmax: 10.0, split: 28, n: 450 },
      { pmin: 10.0, pmax: 20.0, split: 27, n: 1304 },
      { pmin: 20.0, pmax: 30.0, split: 15, n: 1304 },
      { pmin: 30.0, pmax: 40.0, split: 44, n: 1284 },
      { pmin: 40.0, pmax: 1000.0, split: 47, n: 3183 },
    ]
  },
  metrics: {
    rSquared: 0.698782,
    rmse: 1.461002,
    mae: 0.780493
  }
};

// Export for use in modules
if (typeof module !== "undefined" && module.exports) {
  module.exports = { predictAngleError, calculateAimAdjustment, ANGLE_MODEL_INFO };
}
